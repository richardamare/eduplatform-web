import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { useState } from 'react'
import type { Message } from '@/types/message'
import {
  Message as MessageClass,
  MessageId,
  MessageRole,
} from '@/types/message'
import { getMessagesByChatId } from '@/lib/mock-data'

interface UseChatOptions {
  chatId?: string
}

interface SendMessageData {
  content: string
  role: MessageRole
}

export function useChat({ chatId }: UseChatOptions = {}) {
  const queryClient = useQueryClient()
  const [isWaitingForResponse, setIsWaitingForResponse] = useState(false)

  // Query for messages
  const {
    data: messages = [],
    isLoading,
    error,
  } = useQuery({
    queryKey: ['messages', chatId],
    queryFn: () => {
      if (!chatId) return []
      return getMessagesByChatId(chatId)
    },
    enabled: !!chatId,
  })

  // Mutation for sending messages
  const sendMessageMutation = useMutation({
    mutationFn: async (data: SendMessageData): Promise<Message> => {
      // Simulate network delay
      await new Promise((resolve) => setTimeout(resolve, 100))

      const newMessage = new MessageClass({
        id: MessageId.make(`msg_${Date.now()}_${Math.random()}`),
        content: data.content,
        role: data.role,
        createdAt: new Date(),
      })

      return newMessage
    },
    onSuccess: (newMessage) => {
      if (!chatId) return

      // Update the messages cache
      queryClient.setQueryData(
        ['messages', chatId],
        (oldMessages: Array<Message> = []) => [...oldMessages, newMessage],
      )

      // If this is a user message, simulate an assistant response
      if (newMessage.role === MessageRole.USER) {
        setIsWaitingForResponse(true)

        // Simulate response delay
        setTimeout(
          () => {
            const responseMessage = new MessageClass({
              id: MessageId.make(`msg_${Date.now()}_${Math.random()}_response`),
              content: generateMockResponse(newMessage.content),
              role: MessageRole.ASSISTANT,
              createdAt: new Date(),
            })

            queryClient.setQueryData(
              ['messages', chatId],
              (oldMessages: Array<Message> = []) => [
                ...oldMessages,
                responseMessage,
              ],
            )

            setIsWaitingForResponse(false)
          },
          1000 + Math.random() * 2000,
        ) // 1-3 second delay
      }
    },
  })

  const send = (content: string) => {
    sendMessageMutation.mutate({
      content,
      role: MessageRole.USER,
    })
  }

  const submit = send // Alias for send

  return {
    messages,
    isLoading,
    error,
    send,
    submit,
    isWaitingForResponse,
    isSending: sendMessageMutation.isPending,
  }
}

// Mock response generator
function generateMockResponse(userMessage: string): string {
  const responses = [
    `Thanks for your question about "${userMessage.slice(0, 50)}${userMessage.length > 50 ? '...' : ''}". Let me help you with that.

This is a simulated response to demonstrate the chat functionality. In a real application, this would be connected to an AI service or backend API.

Here are some key points to consider:
- This is a mock response for development
- The actual implementation would involve real AI processing
- Response time and quality would vary based on the service used`,

    `I understand you're asking about "${userMessage.slice(0, 30)}${userMessage.length > 30 ? '...' : ''}". 

Here's a detailed explanation:

## Overview
This is a simulated assistant response to help with development and testing.

## Key Concepts
1. **Mock Data**: We're using simulated responses
2. **Real-time Feel**: Responses have realistic delays
3. **Development**: This helps build the UI before connecting real services

\`\`\`typescript
// Example code snippet
function handleUserInput(message: string) {
  return processMessage(message)
}
\`\`\`

Would you like me to elaborate on any specific aspect?`,

    `Interesting question! Let me break this down for you:

### Analysis of "${userMessage.slice(0, 40)}${userMessage.length > 40 ? '...' : ''}"

The topic you've brought up touches on several important areas:

- **Context Understanding**: I can see you're interested in this subject
- **Practical Application**: This has real-world implications
- **Learning Path**: There are multiple ways to approach this

### Recommendations
1. Start with the fundamentals
2. Practice with examples
3. Apply to real projects

This mock response demonstrates how the chat interface works. In production, responses would be generated by an actual AI model with much more sophisticated understanding and capabilities.`,
  ]

  return responses[Math.floor(Math.random() * responses.length)]
}
